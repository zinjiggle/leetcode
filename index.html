<head>
<style type="text/css">
  body {
    margin: auto;
    width: 900px;
  }
</style>

</head>

<body onload="">

<h2>140. Word Break II </h2>
<div class="question-content">
<p>
  Given a string <i>s</i> and a dictionary of words <i>dict</i>, add spaces in <i>s</i> to construct a sentence where each word is a valid dictionary word.
</p>
<p>
  Return all such possible sentences.
</p>
<p>
  For example, given<br>
  <i>s</i> = <code>"catsanddog"</code>,<br>
  <i>dict</i> = <code>["cat", "cats", "and", "sand", "dog"]</code>.
</p>
<p>
  A solution is <code>["cats and dog", "cat sand dog"]</code>.
</p>
</div>

<?prettify?>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
   unordered_map&lt;string, vector&lt;string&gt;&gt; m;

   public:
    vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; dict) {
        if (s.empty()) {
            return {};
        }
        if (m.count(s)) {
            return m[s];
        }
        vector&lt;string&gt; ret;
        if (dict.count(s)) {
            ret.push_back(s);
        }
        for (int i = 1; i &lt; s.length(); ++i) {
            const string end = s.substr(i);
            if (dict.count(end)) {
                const auto &amp;front = wordBreak(s.substr(0, i), dict);
                if (!front.empty()) {
                    const vector&lt;string&gt; new_sols = combine(front, end);
                    ret.insert(ret.end(), new_sols.begin(), new_sols.end());
                }
            }
        }
        m[s] = ret;
        return ret;
    }

    vector&lt;string&gt; combine(const vector&lt;string&gt; &amp;front, const string &amp;end) {
        vector&lt;string&gt; ret;
        for (const string &amp;v : front) {
            ret.push_back(v + " " + end);
        }
        return ret;
    }
};
</code>
</pre>

<h2>146. LRU Cache</h2>

<div class="question-content">
<p>
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.
</p>

<p>
<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>
<code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
</p>
</div>

<?prettify?>
<pre class="prettyprint">
<code class="lang-cc">

struct Node {
  int k = -1;
  int v = -1;
  Node *next = nullptr;
  Node *front = nullptr;
};

class LRUCache{
public:
    LRUCache(int capacity) : cap_(capacity) {
        link(&amp;begin, &amp;end);
    }

    int get(int key) {
        if (!m.count(key)) {
            return -1;
        }
        Node *n = m.at(key);
        Pop(n);
        Add(end.front, &amp;end, n);
        return n->v;
    }

    void link(Node *a, Node *b) {
        a->next = b;
        b->front = a;
    }

    void Pop(Node *n) {
        link(n->front, n->next);
        m.erase(n->k);
    }

    void Add(Node *front, Node *next, Node *n) {
        link(front, n);
        link(n, next);
        m[n->k] = n;
    }

    void AddToEnd(Node *n) {
        Add(end.front, &amp;end, n);
    }

    void set(int key, int value) {
        if (m.count(key)) {
            Node *n = m.at(key);
            n->v = value;
            get(key); // Move it to the end. Set counts as one visit.
        } else {
            Node *n = new Node;
            n->k = key;
            n->v = value;
            if (m.size() >= cap_) {
                Pop(begin.next);
            }
            AddToEnd(n);
        }
    }

    int cap_;
    unordered_map&lt;int, Node*&gt; m;
    Node begin;
    Node end;
};
</code>
</pre>

<h2>155. Min Stack</h2>

<div class="question-content">
<p>
  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p>
<ul>
<li>
  push(x) -- Push element x onto stack.
</li>
<li>
  pop() -- Removes the element on top of the stack.
</li>
<li>
  top() -- Get the top element.
</li>
<li>
  getMin() -- Retrieve the minimum element in the stack.
</li>
</ul>

<p><b>Example:</b><br>
</p><pre>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; Returns -3.
minStack.pop();
minStack.top();      --&gt; Returns 0.
minStack.getMin();   --&gt; Returns -2.
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
  class MinStack {
   public:
    /** initialize your data structure here. */
    MinStack() {

    }

    void push(int x) {
        data_.push_back(x);
        const int pos = data_.size() - 1;
        if (min_.empty()) {
            min_.push_back(pos);
        } else if (getMin() &gt; x) {
            min_.push_back(pos);
        }
    }

    void pop() {
        const int pos = data_.size() - 1;
        data_.pop_back();
        if (pos == *min_.rbegin()) {
            min_.pop_back();
        }
    }

    int top() {
        return *data_.rbegin();
    }

    int getMin() {
        return data_.at(*min_.rbegin());
    }

    vector&lt;int&gt; data_;
    vector&lt;int&gt; min_;
};
</code></pre>

<h2>413. Arithmetic Slices</h2>

<div class="question-content">
<p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>

<p>For example, these are arithmetic sequence:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>

<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>

<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>

<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>
    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>

<p>The function should return the number of arithmetic slices in the array A. </p>

<p><b>Example:</b>
</p><pre>A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
</pre>
</div>

<h3>My solution based on MATH.</h3>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
  class Solution {
   public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        if (A.size() &lt; 3) {
            return 0;
        }
        vector&lt;int&gt; can;
        for (int i = 0; i &lt; A.size() - 2;) {
            if (!isCandi(A, i)) {
                ++i;
                continue;
            }
            int len = findSeq(A, i);
            can.push_back(len);
            i += len - 1;
        }
        return sum(can);
    }

    bool isCandi(const vector&lt;int&gt; &amp;A, int i) {
        return A[i+1] - A[i] == A[i+2] - A[i+1];
    }

    int findSeq(const vector&lt;int&gt; &amp;A, int i) {
        const int dis = A[i+1] - A[i];
        int j = i + 1;
        for (; j &lt; A.size() &amp;&amp; dis == A[j] - A[j-1]; ++j) {
        }
        return j - i;

    }

    int sum(const vector&lt;int&gt; &amp;candi) {
        int ret = 0;
        for (const int v : candi) {
            ret += (v-1)*(v-2) / 2;
        }
        return ret;
    }
};
</code></pre>

<h3>Web solution based on Dynamic Programming.</h3>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        int n = A.size();
        if (n &lt; 3) return 0;
        // dp[i] means the number of arithmetic slices ending with A[i]
        vector&lt;int&gt; dp(n, 0);
        // if the first three numbers are arithmetic or not
        if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1;
        int result = dp[2];
        for (int i = 3; i &lt; n; ++i) {
            // if A[i-2], A[i-1], A[i] are arithmetic,
            // then the number of arithmetic slices ending with A[i] (dp[i])
            // equals to:
            //      the number of arithmetic slices ending with A[i-1] (dp[i-1],
            //      all these arithmetic slices appending A[i] are also arithmetic)
            //      +
            //      A[i-2], A[i-1], A[i] (a brand new arithmetic slice)
            // it is how dp[i] = dp[i-1] + 1 comes
            if (A[i]-A[i-1] == A[i-1]-A[i-2])
                dp[i] = dp[i-1] + 1;
            result += dp[i]; // accumulate all valid slices
        }
        return result;
    }
};
</code></pre>






<h2>446. Arithmetic Slices II - Subsequence   QuestionEditorial Solution</h2>
<div class="question-content">
<p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>

<p>For example, these are arithmetic sequences:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>

<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>

<p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 ≤ P<sub>0</sub> &lt; P<sub>1</sub> &lt; ... &lt; P<sub>k</sub> &lt; N.</p>

<p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k ≥ 2.</p>

<p>The function should return the number of arithmetic subsequence slices in the array A. </p>

<p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>

<p><b>Example:</b>
</p><pre><b>Input:</b> [2, 4, 6, 8, 10]

<b>Output:</b> 7

<b>Explanation:</b>
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        if (A.size() &lt; 3) {
            return 0;
        }
        int ret = 0;
        // index -> diff -> count.
        // Number of Arithmetic slices ending at index, with diff, min length is 2.
        vector&lt;unordered_map&lt;int, int&gt;&gt; dp(A.size());
        for (int i = 0; i &lt; A.size(); ++i) {
            for (int j = 0; j &lt; i; ++j) {
                const long bound = long(A[i]) - long(A[j]);
                if (bound >= INT_MAX || bound <= INT_MIN) {
                    continue;
                }
                const int diff = A[i] - A[j];
                dp[i][diff] += 1;
                if (dp[j].count(diff)) {
                    dp[i][diff] += dp[j][diff];
                    ret += dp[j][diff];
                }
            }
        }
        return ret;
    }
};
</code></pre>


<h2>397. Integer Replacement   QuestionEditorial Solution</h2>

<div class="question-content">
<p>
Given a positive integer <i>n</i> and you can do operations as follow:
</p>

<p>
</p><ol>
<li>If <i>n</i> is even, replace <i>n</i> with <code><i>n</i>/2</code>.</li>
<li>If <i>n</i> is odd, you can replace <i>n</i> with either <code><i>n</i> + 1</code> or <code><i>n</i> - 1</code>.</li>
</ol>

<p>
What is the minimum number of replacements needed for <i>n</i> to become 1?
</p>

<p><b>Example 1:</b>
</p><pre><b>Input:</b>
8

<b>Output:</b>
3

<b>Explanation:</b>
8 -&gt; 4 -&gt; 2 -&gt; 1
</pre>

<p><b>Example 2:</b>
</p><pre><b>Input:</b>
7

<b>Output:</b>
4

<b>Explanation:</b>
7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
or
7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int integerReplacement(int n) {
        // Check tails:
        //   00 -> /2
        //   10 -> /2
        //   11 -> +1
        //   01 -> -1
        if (n == 1) {
            return 0;
        }
        if (n == 0) {
            return INT_MAX;
        }
        if (n == INT_MAX) {
            return 32;
        }
        if (n == 2) {
            return 1;
        }
        if (n == 3) {
            return 2;
        }
        const int last = (n &amp; 3);
        if (last == 3) {
            return integerReplacement(n + 1) + 1;
        } else if (last == 1) {
            return integerReplacement(n - 1) + 1;
        }
        return integerReplacement(n / 2) + 1;
    }
};
</code></pre>

<h2>395. Longest Substring with At Least K Repeating Characters   QuestionEditorial Solution</h2>

<div class="question-content">
<p>
Find the length of the longest substring <b><i>T</i></b> of a given string (consists of lowercase letters only) such that every character in <b><i>T</i></b> appears no less than <i>k</i> times.
</p>

<p><b>Example 1:</b>
</p><pre>Input:
s = "aaabb", k = 3

Output:
3

The longest substring is "aaa", as 'a' is repeated 3 times.
</pre>

<p><b>Example 2:</b>
</p><pre>Input:
s = "ababbc", k = 2

Output:
5

The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
</pre>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int longestSubstring(string s, int k) {
        return divideAndConqur(s, 0, s.size(), k);
    }

    // It takes O(logn) iterations and each iteration takes O(n) so the time
    // complexity is O(nlogn).
    int divideAndConqur(const string &amp;s, int b, int e, int k) {
        if ((e - b) &lt; k) {
            return 0;
        }
        int cnt[26]{}; // Initialize all to 0.
        for (int i = b; i &lt; e; ++i) {
            const int val = s[i] - 'a';
            cnt[val] += 1;
        }
        for (int i = b; i &lt; e; ++i) {
            const int val = s[i] - 'a';
            if (cnt[val] &lt; k) {
                // If we found one element whose total &lt; k, then any sub string containing
                // that element cannot be taken into consideration.
                return max(divideAndConqur(s, b, i, k), divideAndConqur(s, i+1, e, k));
            }
        }
        return e - b;
    }
};
</code></pre>

<p>
Thanks to <a href="https://discuss.leetcode.com/topic/64483/10-lines-c-solution-clear-and-simple-3ms">wfxr</a>
for enlightening.
</p>
<p>One O(n) time complexity solution is <a href="https://discuss.leetcode.com/topic/65229/c-o-n-simple-recursive-solution/2">here</a>, but it consumes O(n) extra memory as well.</p>

<h2>314. FACEBOOK <a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"> Binary Tree Vertical Order Traversal</a></h2>

<p><a href="https://discuss.leetcode.com/topic/31109/my-solution-in-c/3">Nice and short solution</a></p>

<div class="question-content">
<p>Given a binary tree, return the <i>vertical order</i> traversal of its nodes' values. (ie, from top to bottom, column by column).</p>
<p>If two nodes are in the same row and column, the order should be from <b>left to right</b>.</p>
<p>
<b>Examples:</b><br></p>
<p>
</p><ol>
<li>Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>
<pre>   3
  /\
 /  \
 9  20
    /\
   /  \
  15   7
</pre>
<p></p>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [9],
  [3,15],
  [20],
  [7]
]
</pre>
</li>

<li>Given binary tree <code>[3,9,8,4,0,1,7]</code>,<br>
<pre>     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
</pre>
<p></p>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]
</pre>
</li>

<li>Given binary tree <code>[3,9,8,4,0,1,7,null,null,null,2,5]</code> (0's right child is 2 and 1's left child is 5),<br>
<pre>     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2
</pre>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]
</pre>
</li>
</ol>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    struct NodeColumn {
        TreeNode *node;
        int col;
    };

    struct Size {
        int left;
        int right;
    };

    Size GetColumnSize(TreeNode *root) {
        if (root == nullptr) {
            return Size{0, 0};
        }
        const Size &amp;left = GetColumnSize(root->left);
        const Size &amp;right = GetColumnSize(root->right);
        return Size {
            std::max(left.left + 1, right.left - 1),
            std::max(left.right - 1, right.right + 1)
        };
    }

    vector&lt;vector&lt;int&gt;&gt; verticalOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; ret;
        if (root == nullptr) {
            return ret;
        }
        const Size &amp;size = GetColumnSize(root);
        ret.resize(size.left + size.right - 1, {});
        // Traverse using queue.
        std::queue&lt;NodeColumn&gt; trav;
        trav.push(NodeColumn{root, size.left - 1});
        while (!trav.empty()) {
            const NodeColumn &amp;current = trav.front();
            trav.pop();
            ret[current.col].push_back(current.node->val);
            if (current.node->left) {
                trav.push(NodeColumn{current.node->left, current.col - 1});
            }
            if (current.node->right) {
                trav.push(NodeColumn{current.node->right, current.col + 1});
            }

        }
        return ret;
    }
};
</code></pre>

<!--
<h2>314. Binary Tree Vertical Order Traversal</h2>
-->

<h2>273. <a href="https://leetcode.com/problems/integer-to-english-words/">Integer to English Words </a> </h2>
<div class="question-content">
<p>
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.
</p>

<p>For example,<br>
</p><pre>123 -&gt; "One Hundred Twenty Three"
12345 -&gt; "Twelve Thousand Three Hundred Forty Five"
1234567 -&gt; "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</pre>

<p><a href="https://discuss.leetcode.com/topic/23054/my-clean-java-solution-very-easy-to-understand/2">Good solution</a></p>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:

    void trim(string *str) {
        while (*str->rbegin() == ' ') {
            str->pop_back();
        }
    }

    string join(const vector&lt;string&gt; &amp;input) {
        string ret;
        for (const string &amp;t : input) {
            if (!t.empty()) {
                ret.append(t);
                ret.append(" ");
            }
        }
        trim(&amp;ret);
        return ret;
    }

    string numberToWords(int num) {
        if (num == 0) {
            return "Zero";
        }
        static const vector&lt;string&gt; split = {
            "",
            "Thousand",
            "Million",
            "Billion",
            "Trillion"
        };
        vector&lt;string&gt; all_tokens;
        int i = 0;
        while (num &gt; 0) {
            const int under_thou = num - (num / 1000) * 1000;
            num /= 1000;
            const string &amp;token = BelowThousand(under_thou);
            if (!token.empty()) {
                all_tokens.push_back(join({
                    token, split[i]
                }));
            }
            ++i;
        }
        std::reverse(all_tokens.begin(), all_tokens.end());
        return join(all_tokens);
    }


    string TokenTranslate(int num) {
        static const map&lt;int, string&gt; mapping = {
            {0, ""},
            {1, "One"},
            {2, "Two"},
            {3, "Three"},
            {4, "Four"},
            {5, "Five"},
            {6, "Six"},
            {7, "Seven"},
            {8, "Eight"},
            {9, "Nine"},
            {10, "Ten"},
            {11, "Eleven"},
            {12, "Twelve"},
            {13, "Thirteen"},
            {14, "Fourteen"},
            {15, "Fifteen"},
            {16, "Sixteen"},
            {17, "Seventeen"},
            {18, "Eighteen"},
            {19, "Nineteen"},
            {20, "Twenty"},
            {30, "Thirty"},
            {40, "Forty"},
            {50, "Fifty"},
            {60, "Sixty"},
            {70, "Seventy"},
            {80, "Eighty"},
            {90, "Ninety"}
        };
        return mapping.at(num);
    }

    string BelowHundred(int num) {
        // num &lt; 100.
        if (num &lt; 20) {
            return TokenTranslate(num);
        }
        int tens = (num / 10) * 10;
        return join({
            TokenTranslate(tens), TokenTranslate(num - tens)
        });
    }

    string BelowThousand(int num) {
        // num &lt; 1000.
        if (num &lt; 100) {
            return BelowHundred(num);
        }
        return join({
            BelowHundred(num / 100), "Hundred", BelowHundred(num - (num / 100) * 100)
        });
    }
};

</code></pre>

<!--
<h2>273. Integer to English Words  </h2>
-->


<h2>410. Split Array Largest Sum BAIDU</h2>

<div class="question-content">
<p>Given an array which consists of non-negative integers and an integer <i>m</i>, you can split the array into <i>m</i> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <i>m</i> subarrays.
</p>

<p><b>Note:</b><br>
Given <i>m</i> satisfies the following constraint: 1 ≤ m ≤  length(nums) ≤ 14,000.
</p>

<p><b>Examples: </b>
</p><pre>Input:
<b>nums</b> = [7,2,5,10,8]
<b>m</b> = 2

Output:
18

Explanation:
There are four ways to split <b>nums</b> into two subarrays.
The best way is to split it into <b>[7,2,5]</b> and <b>[10,8]</b>,
where the largest sum among the two subarrays is only 18.
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() < m) {
            return 0;
        }
        long max = sum(nums);
        long min = MaxVal(nums);
        while (min < max) {
            const long mid = (min + max) / 2;
            if (IsValid(nums, m, mid)) {
                // It is valid to find a partition of m sub arrays with the
                // largest sum <= mid.
                // In this case, we should try a smaller mid to see whether
                // there are better solutions.
                max = mid;
            } else {
                // We increase mid to see whether there is valid solution.
                min = mid + 1;
            }
        }
        return min;
    }

    // Returns true if there is one partition of m with the largest sum <= max.
    // This function can be done in O(n).
    bool IsValid(const vector&lt;int&gt; &amp;n, int m, long max) {
        long sum = 0;
        int group = 1;
        for (const int i : n) {
            if (sum + i <= max) {
                // Put as many element as possible into previous partition.
                sum += i;
            } else {
                // The previous partition ends, start a new partition.
                sum = i;
                ++group;
            }
            if (group > m || sum > max) {
                return false;
            }
        }
        return true;
    }

    // Sum of vectors, using long because int will over flow.
    long sum(const vector&lt;int&gt; &amp;n) {
        long ret = 0;
        for (const int i : n) {
            ret += i;
        }
        return ret;
    }

    // The max value in the vector.
    int MaxVal(const vector&lt;int&gt; &amp;n) {
        int ret = 0;
        for (const int i : n) {
            ret = std::max(ret, i);
        }
        return ret;
    }
};
</code></pre>

<!--
<h2>410. Split Array Largest Sum BAIDU</h2>
-->

<h2>161. One Edit Distance SNAPCHAT</h2>
<p>Given two strings S and T, determine if they are both one edit distance apart.
</p>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        if (s.empty() || t.empty()) {
            return s.size() + t.size() == 1;
        }
        if (s.size() == t.size()) {
            // When the two has the same size, check whether only one char differs.
            int diff = 0;
            for (int i = 0; i < s.size() &amp;&amp; diff <= 1; ++i) {
                // Put diff <= 1 here to early terminate the loop.
                if (s.at(i) != t.at(i)) {
                    ++diff;
                }
            }
            return diff == 1;
        }
        // Find the shorter string.
        const string &amp;small = s.size() < t.size() ? s : t;
        const string &amp;large = s.size() < t.size() ? t : s;
        if (small.size() + 1 != large.size()) {
            // If the two has distance not equal to one, false.
            return false;
        }
        for (int i = 0; i < small.size(); i++) {
            if (small.at(i) != large.at(i)) {
                // Find the first character mismatch, than compare the following characters.
                return small.substr(i) == large.substr(i + 1);
            }
        }
        return true;
    }
};
</code></pre>
<!--
<h2>161. One Edit Distance</h2>
-->

<h2>36. Valid Sudoku </h2>

<div class="question-content">
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A partially filled sudoku which is valid.</p>
<p></p>

<p><b>Note:</b><br>
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using BOA = vector&lt;vector&lt;char&gt;&gt;;

    bool ValidOrAdd(bitset&lt;9&gt; *n, const char val) {
        if (val != '.') {
            const int p = val - '1';
            if (n->test(p)) {
                return false;
            } else {
                n->set(p);
                return true;
            }
        }
        return true;
    }

    bool isValidSudoku(const BOA &amp;b) {
        for (int i = 0; i < 9; i++) {
             bitset&lt;9&gt; n;
             for (int j = 0; j < 9; j++) {
                 if (!ValidOrAdd(&amp;n, b[i][j])) {
                     return false;
                 }
             }
        }
        for (int j = 0; j < 9; j++) {
            bitset&lt;9&gt; n;
            for (int i = 0; i < 9; i++) {
                if (!ValidOrAdd(&amp;n, b[i][j])) {
                    return false;
                }
            }
        }
        for (int i = 0; i < 9; i+=3) {
            for (int j = 0; j < 9; j+=3) {
                bitset&lt;9&gt; n;
                for (int k = i; k < i + 3; k++) {
                    for (int f = j; f < j + 3; f++) {
                        if (!ValidOrAdd(&amp;n, b[k][f])) {
                            return false;
                        }
                    }
                }
            }
        }

        return true;
    }
};
</code></pre>

<!--
<h2>36. Valid Sudoku </h2>
-->

<h2>37. Sudoku Solver SNAPCHAT</h2>

<div class="question-content">
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character <code>'.'</code>.</p>

<p>You may assume that there will be only one unique solution.

</p><p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A sudoku puzzle...</p>
<p></p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"><br>
</p><p style="font-size: 11px">...and its solution numbers marked in red.
</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        solve(board);
    }
private:

    using BOA = vector&lt;vector&lt;char&gt;&gt;;
    using BIT = bitset&lt;9&gt;;
    struct POS {
        int r;
        int c;
        int cell() const {
            return (r/3) * 3 + (c/3);
        }
    };

    BIT row[10];
    BIT col[10];
    BIT cell[10];

    void change(BIT *val, int num, bool bitval) {
        if (bitval) {
            val->set(num);
        } else {
            val->reset(num);
        }
    }

    bool valid(const BOA &amp;b, const POS &amp;p, char val) {
        // Returns true if it is OK to put val in (r, c).
        const int test = val - '1';
        return !(row[p.r].test(test)) &amp;&amp; !(col[p.c].test(test)) &amp;&amp; !(cell[p.cell()].test(test));
    }

    void set(BOA &amp;b, const POS &amp;p, char val) {
        const int test = val - '1';
        b[p.r][p.c] = val;
        change(&amp;row[p.r], test, true);
        change(&amp;col[p.c], test, true);
        change(&amp;cell[p.cell()], test, true);
    }

    void clear(BOA &amp;b, const POS &amp;p) {
        const int test = b[p.r][p.c] - '1';
        b[p.r][p.c] = '.';
        change(&amp;row[p.r], test, false);
        change(&amp;col[p.c], test, false);
        change(&amp;cell[p.cell()], test, false);
    }

    bool helper(BOA &amp;b, vector&lt;POS&gt; &amp;candi) {
        if (candi.empty()) {
            return true;
        }
        const POS p = *candi.rbegin();
        candi.pop_back();
        for (char d = '1'; d <= '9'; d++) {
            if (valid(b, p, d)) {
                set(b, p, d);
                if (helper(b, candi)) return true;
                clear(b, p);
            }
        }
        candi.push_back(p);
        return false;
    }

    void sort(vector&lt;POS&gt; &amp;candi) {
        std::sort(candi.begin(), candi.end(), [this](const POS &amp;a, const POS &amp;b) {
            int c_a = row[a.r].count() + col[a.c].count() + cell[a.cell()].count();
            int c_b = row[b.r].count() + col[b.c].count() + cell[b.cell()].count();
            return c_a < c_b;
        });
    }

    bool solve(BOA &amp;board) {
        vector&lt;POS&gt; candi;
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                const POS p {r, c};
                if (board[p.r][p.c] != '.') {
                    set(board, p, board[p.r][p.c]);
                } else {
                    candi.push_back(p);
                }
            }
        }
        sort(candi);
        return helper(board, candi);
    }
};
</code></pre>

<!--
<h2>37. Sudoku Solver </h2>
-->

<h2>127. Word Ladder </h2>
<div class="question-content">
<p>
Given two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find the length of shortest transformation sequence from <i>beginWord</i> to <i>endWord</i>, such that:
</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the word list</li>
</ol>

<p>
For example,
</p>
<p>
Given:<br>
<i>beginWord</i> = <code>"hit"</code><br>
<i>endWord</i> = <code>"cog"</code><br>
<i>wordList</i> = <code>["hot","dot","dog","lot","log"]</code><br>
</p>
<p>
As one shortest transformation is <code>"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"</code>,<br>
return its length <code>5</code>.
</p>

<p>
<b>Note:</b><br>
</p><ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using SET = unordered_set&lt;string&gt;;
    int ladderLength(string beg, string end, unordered_set&lt;string&gt;&amp; w) {
        if (beg == end) {
            return 1;
        }
        SET left, right, *pleft, *pright;
        int dist = 2;
        left.insert(beg);
        right.insert(end);
        w.erase(beg);
        w.erase(end);

        while (!left.empty() &amp;&amp; !right.empty()) {
            if (left.size() <= right.size()) {
                // We plan to process the one with smaller size first.
                // As it can be more balanced in that way.
                pleft = &amp;left;
                pright = &amp;right;
            } else {
                pleft = &amp;right;
                pright = &amp;left;
            }
            SET temp; // Store all neighbors of elements in pleft.
            for (string v : *pleft) {
                for (int i = 0; i < v.size(); ++i) {
                const char ori = v[i];
                for (char d = 'a'; d <= 'z'; ++d) {
                    v[i] = d;
                    if (pright->find(v) != pright->end()) {
                        return dist;
                    }
                    if (w.find(v) != w.end()) {
                        temp.insert(v);
                        w.erase(v);
                    }
                }
                v[i] = ori;
            }
            }
            swap(*pleft, temp);
            ++dist;
        }
        return 0;
    }
};
</code></pre>


<script src="http://code.jquery.com/jquery-2.2.2.min.js"></script>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</body>

