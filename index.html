<head>
<style type="text/css">
  body {
    margin: auto;
    width: 900px;
  }
</style>

</head>

<body onload="">

<h2>140. Word Break II </h2>
<div class="question-content">
<p>
  Given a string <i>s</i> and a dictionary of words <i>dict</i>, add spaces in <i>s</i> to construct a sentence where each word is a valid dictionary word.
</p>
<p>
  Return all such possible sentences.
</p>
<p>
  For example, given<br>
  <i>s</i> = <code>"catsanddog"</code>,<br>
  <i>dict</i> = <code>["cat", "cats", "and", "sand", "dog"]</code>.
</p>
<p>
  A solution is <code>["cats and dog", "cat sand dog"]</code>.
</p>
</div>

<?prettify?>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
   unordered_map&lt;string, vector&lt;string&gt;&gt; m;

   public:
    vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; dict) {
        if (s.empty()) {
            return {};
        }
        if (m.count(s)) {
            return m[s];
        }
        vector&lt;string&gt; ret;
        if (dict.count(s)) {
            ret.push_back(s);
        }
        for (int i = 1; i &lt; s.length(); ++i) {
            const string end = s.substr(i);
            if (dict.count(end)) {
                const auto &amp;front = wordBreak(s.substr(0, i), dict);
                if (!front.empty()) {
                    const vector&lt;string&gt; new_sols = combine(front, end);
                    ret.insert(ret.end(), new_sols.begin(), new_sols.end());
                }
            }
        }
        m[s] = ret;
        return ret;
    }

    vector&lt;string&gt; combine(const vector&lt;string&gt; &amp;front, const string &amp;end) {
        vector&lt;string&gt; ret;
        for (const string &amp;v : front) {
            ret.push_back(v + " " + end);
        }
        return ret;
    }
};
</code>
</pre>

<h2>146. LRU Cache</h2>

<div class="question-content">
<p>
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.
</p>

<p>
<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>
<code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
</p>
</div>

<?prettify?>
<pre class="prettyprint">
<code class="lang-cc">

struct Node {
  int k = -1;
  int v = -1;
  Node *next = nullptr;
  Node *front = nullptr;
};

class LRUCache{
public:
    LRUCache(int capacity) : cap_(capacity) {
        link(&amp;begin, &amp;end);
    }

    int get(int key) {
        if (!m.count(key)) {
            return -1;
        }
        Node *n = m.at(key);
        Pop(n);
        Add(end.front, &amp;end, n);
        return n->v;
    }

    void link(Node *a, Node *b) {
        a->next = b;
        b->front = a;
    }

    void Pop(Node *n) {
        link(n->front, n->next);
        m.erase(n->k);
    }

    void Add(Node *front, Node *next, Node *n) {
        link(front, n);
        link(n, next);
        m[n->k] = n;
    }

    void AddToEnd(Node *n) {
        Add(end.front, &amp;end, n);
    }

    void set(int key, int value) {
        if (m.count(key)) {
            Node *n = m.at(key);
            n->v = value;
            get(key); // Move it to the end. Set counts as one visit.
        } else {
            Node *n = new Node;
            n->k = key;
            n->v = value;
            if (m.size() >= cap_) {
                Pop(begin.next);
            }
            AddToEnd(n);
        }
    }

    int cap_;
    unordered_map&lt;int, Node*&gt; m;
    Node begin;
    Node end;
};
</code>
</pre>

<h2>155. Min Stack</h2>

<div class="question-content">
<p>
  Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p>
<ul>
<li>
  push(x) -- Push element x onto stack.
</li>
<li>
  pop() -- Removes the element on top of the stack.
</li>
<li>
  top() -- Get the top element.
</li>
<li>
  getMin() -- Retrieve the minimum element in the stack.
</li>
</ul>

<p><b>Example:</b><br>
</p><pre>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; Returns -3.
minStack.pop();
minStack.top();      --&gt; Returns 0.
minStack.getMin();   --&gt; Returns -2.
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
  class MinStack {
   public:
    /** initialize your data structure here. */
    MinStack() {

    }

    void push(int x) {
        data_.push_back(x);
        const int pos = data_.size() - 1;
        if (min_.empty()) {
            min_.push_back(pos);
        } else if (getMin() &gt; x) {
            min_.push_back(pos);
        }
    }

    void pop() {
        const int pos = data_.size() - 1;
        data_.pop_back();
        if (pos == *min_.rbegin()) {
            min_.pop_back();
        }
    }

    int top() {
        return *data_.rbegin();
    }

    int getMin() {
        return data_.at(*min_.rbegin());
    }

    vector&lt;int&gt; data_;
    vector&lt;int&gt; min_;
};
</code></pre>

<h2>413. Arithmetic Slices</h2>

<div class="question-content">
<p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>

<p>For example, these are arithmetic sequence:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>

<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>

<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>

<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>
    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>

<p>The function should return the number of arithmetic slices in the array A. </p>

<p><b>Example:</b>
</p><pre>A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
</pre>
</div>

<h3>My solution based on MATH.</h3>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
  class Solution {
   public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        if (A.size() &lt; 3) {
            return 0;
        }
        vector&lt;int&gt; can;
        for (int i = 0; i &lt; A.size() - 2;) {
            if (!isCandi(A, i)) {
                ++i;
                continue;
            }
            int len = findSeq(A, i);
            can.push_back(len);
            i += len - 1;
        }
        return sum(can);
    }

    bool isCandi(const vector&lt;int&gt; &amp;A, int i) {
        return A[i+1] - A[i] == A[i+2] - A[i+1];
    }

    int findSeq(const vector&lt;int&gt; &amp;A, int i) {
        const int dis = A[i+1] - A[i];
        int j = i + 1;
        for (; j &lt; A.size() &amp;&amp; dis == A[j] - A[j-1]; ++j) {
        }
        return j - i;

    }

    int sum(const vector&lt;int&gt; &amp;candi) {
        int ret = 0;
        for (const int v : candi) {
            ret += (v-1)*(v-2) / 2;
        }
        return ret;
    }
};
</code></pre>

<h3>Web solution based on Dynamic Programming.</h3>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        int n = A.size();
        if (n &lt; 3) return 0;
        // dp[i] means the number of arithmetic slices ending with A[i]
        vector&lt;int&gt; dp(n, 0);
        // if the first three numbers are arithmetic or not
        if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1;
        int result = dp[2];
        for (int i = 3; i &lt; n; ++i) {
            // if A[i-2], A[i-1], A[i] are arithmetic,
            // then the number of arithmetic slices ending with A[i] (dp[i])
            // equals to:
            //      the number of arithmetic slices ending with A[i-1] (dp[i-1],
            //      all these arithmetic slices appending A[i] are also arithmetic)
            //      +
            //      A[i-2], A[i-1], A[i] (a brand new arithmetic slice)
            // it is how dp[i] = dp[i-1] + 1 comes
            if (A[i]-A[i-1] == A[i-1]-A[i-2])
                dp[i] = dp[i-1] + 1;
            result += dp[i]; // accumulate all valid slices
        }
        return result;
    }
};
</code></pre>






<h2>446. Arithmetic Slices II - Subsequence   QuestionEditorial Solution</h2>
<div class="question-content">
<p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>

<p>For example, these are arithmetic sequences:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>

<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>

<p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 ≤ P<sub>0</sub> &lt; P<sub>1</sub> &lt; ... &lt; P<sub>k</sub> &lt; N.</p>

<p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k ≥ 2.</p>

<p>The function should return the number of arithmetic subsequence slices in the array A. </p>

<p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>

<p><b>Example:</b>
</p><pre><b>Input:</b> [2, 4, 6, 8, 10]

<b>Output:</b> 7

<b>Explanation:</b>
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) {
        if (A.size() &lt; 3) {
            return 0;
        }
        int ret = 0;
        // index -> diff -> count.
        // Number of Arithmetic slices ending at index, with diff, min length is 2.
        vector&lt;unordered_map&lt;int, int&gt;&gt; dp(A.size());
        for (int i = 0; i &lt; A.size(); ++i) {
            for (int j = 0; j &lt; i; ++j) {
                const long bound = long(A[i]) - long(A[j]);
                if (bound >= INT_MAX || bound <= INT_MIN) {
                    continue;
                }
                const int diff = A[i] - A[j];
                dp[i][diff] += 1;
                if (dp[j].count(diff)) {
                    dp[i][diff] += dp[j][diff];
                    ret += dp[j][diff];
                }
            }
        }
        return ret;
    }
};
</code></pre>


<h2>397. Integer Replacement   QuestionEditorial Solution</h2>

<div class="question-content">
<p>
Given a positive integer <i>n</i> and you can do operations as follow:
</p>

<p>
</p><ol>
<li>If <i>n</i> is even, replace <i>n</i> with <code><i>n</i>/2</code>.</li>
<li>If <i>n</i> is odd, you can replace <i>n</i> with either <code><i>n</i> + 1</code> or <code><i>n</i> - 1</code>.</li>
</ol>

<p>
What is the minimum number of replacements needed for <i>n</i> to become 1?
</p>

<p><b>Example 1:</b>
</p><pre><b>Input:</b>
8

<b>Output:</b>
3

<b>Explanation:</b>
8 -&gt; 4 -&gt; 2 -&gt; 1
</pre>

<p><b>Example 2:</b>
</p><pre><b>Input:</b>
7

<b>Output:</b>
4

<b>Explanation:</b>
7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
or
7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int integerReplacement(int n) {
        // Check tails:
        //   00 -> /2
        //   10 -> /2
        //   11 -> +1
        //   01 -> -1
        if (n == 1) {
            return 0;
        }
        if (n == 0) {
            return INT_MAX;
        }
        if (n == INT_MAX) {
            return 32;
        }
        if (n == 2) {
            return 1;
        }
        if (n == 3) {
            return 2;
        }
        const int last = (n &amp; 3);
        if (last == 3) {
            return integerReplacement(n + 1) + 1;
        } else if (last == 1) {
            return integerReplacement(n - 1) + 1;
        }
        return integerReplacement(n / 2) + 1;
    }
};
</code></pre>

<h2>395. Longest Substring with At Least K Repeating Characters   QuestionEditorial Solution</h2>

<div class="question-content">
<p>
Find the length of the longest substring <b><i>T</i></b> of a given string (consists of lowercase letters only) such that every character in <b><i>T</i></b> appears no less than <i>k</i> times.
</p>

<p><b>Example 1:</b>
</p><pre>Input:
s = "aaabb", k = 3

Output:
3

The longest substring is "aaa", as 'a' is repeated 3 times.
</pre>

<p><b>Example 2:</b>
</p><pre>Input:
s = "ababbc", k = 2

Output:
5

The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
</pre>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int longestSubstring(string s, int k) {
        return divideAndConqur(s, 0, s.size(), k);
    }

    // It takes O(logn) iterations and each iteration takes O(n) so the time
    // complexity is O(nlogn).
    int divideAndConqur(const string &amp;s, int b, int e, int k) {
        if ((e - b) &lt; k) {
            return 0;
        }
        int cnt[26]{}; // Initialize all to 0.
        for (int i = b; i &lt; e; ++i) {
            const int val = s[i] - 'a';
            cnt[val] += 1;
        }
        for (int i = b; i &lt; e; ++i) {
            const int val = s[i] - 'a';
            if (cnt[val] &lt; k) {
                // If we found one element whose total &lt; k, then any sub string containing
                // that element cannot be taken into consideration.
                return max(divideAndConqur(s, b, i, k), divideAndConqur(s, i+1, e, k));
            }
        }
        return e - b;
    }
};
</code></pre>

<p>
Thanks to <a href="https://discuss.leetcode.com/topic/64483/10-lines-c-solution-clear-and-simple-3ms">wfxr</a>
for enlightening.
</p>
<p>One O(n) time complexity solution is <a href="https://discuss.leetcode.com/topic/65229/c-o-n-simple-recursive-solution/2">here</a>, but it consumes O(n) extra memory as well.</p>

<h2>314. FACEBOOK <a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"> Binary Tree Vertical Order Traversal</a></h2>

<p><a href="https://discuss.leetcode.com/topic/31109/my-solution-in-c/3">Nice and short solution</a></p>

<div class="question-content">
<p>Given a binary tree, return the <i>vertical order</i> traversal of its nodes' values. (ie, from top to bottom, column by column).</p>
<p>If two nodes are in the same row and column, the order should be from <b>left to right</b>.</p>
<p>
<b>Examples:</b><br></p>
<p>
</p><ol>
<li>Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>
<pre>   3
  /\
 /  \
 9  20
    /\
   /  \
  15   7
</pre>
<p></p>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [9],
  [3,15],
  [20],
  [7]
]
</pre>
</li>

<li>Given binary tree <code>[3,9,8,4,0,1,7]</code>,<br>
<pre>     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
</pre>
<p></p>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]
</pre>
</li>

<li>Given binary tree <code>[3,9,8,4,0,1,7,null,null,null,2,5]</code> (0's right child is 2 and 1's left child is 5),<br>
<pre>     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2
</pre>
<p>
return its vertical order traversal as:<br>
</p><pre>[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]
</pre>
</li>
</ol>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    struct NodeColumn {
        TreeNode *node;
        int col;
    };

    struct Size {
        int left;
        int right;
    };

    Size GetColumnSize(TreeNode *root) {
        if (root == nullptr) {
            return Size{0, 0};
        }
        const Size &amp;left = GetColumnSize(root->left);
        const Size &amp;right = GetColumnSize(root->right);
        return Size {
            std::max(left.left + 1, right.left - 1),
            std::max(left.right - 1, right.right + 1)
        };
    }

    vector&lt;vector&lt;int&gt;&gt; verticalOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; ret;
        if (root == nullptr) {
            return ret;
        }
        const Size &amp;size = GetColumnSize(root);
        ret.resize(size.left + size.right - 1, {});
        // Traverse using queue.
        std::queue&lt;NodeColumn&gt; trav;
        trav.push(NodeColumn{root, size.left - 1});
        while (!trav.empty()) {
            const NodeColumn &amp;current = trav.front();
            trav.pop();
            ret[current.col].push_back(current.node->val);
            if (current.node->left) {
                trav.push(NodeColumn{current.node->left, current.col - 1});
            }
            if (current.node->right) {
                trav.push(NodeColumn{current.node->right, current.col + 1});
            }

        }
        return ret;
    }
};
</code></pre>

<!--
<h2>314. Binary Tree Vertical Order Traversal</h2>
-->

<h2>273. <a href="https://leetcode.com/problems/integer-to-english-words/">Integer to English Words </a> </h2>
<div class="question-content">
<p>
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.
</p>

<p>For example,<br>
</p><pre>123 -&gt; "One Hundred Twenty Three"
12345 -&gt; "Twelve Thousand Three Hundred Forty Five"
1234567 -&gt; "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</pre>

<p><a href="https://discuss.leetcode.com/topic/23054/my-clean-java-solution-very-easy-to-understand/2">Good solution</a></p>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:

    void trim(string *str) {
        while (*str->rbegin() == ' ') {
            str->pop_back();
        }
    }

    string join(const vector&lt;string&gt; &amp;input) {
        string ret;
        for (const string &amp;t : input) {
            if (!t.empty()) {
                ret.append(t);
                ret.append(" ");
            }
        }
        trim(&amp;ret);
        return ret;
    }

    string numberToWords(int num) {
        if (num == 0) {
            return "Zero";
        }
        static const vector&lt;string&gt; split = {
            "",
            "Thousand",
            "Million",
            "Billion",
            "Trillion"
        };
        vector&lt;string&gt; all_tokens;
        int i = 0;
        while (num &gt; 0) {
            const int under_thou = num - (num / 1000) * 1000;
            num /= 1000;
            const string &amp;token = BelowThousand(under_thou);
            if (!token.empty()) {
                all_tokens.push_back(join({
                    token, split[i]
                }));
            }
            ++i;
        }
        std::reverse(all_tokens.begin(), all_tokens.end());
        return join(all_tokens);
    }


    string TokenTranslate(int num) {
        static const map&lt;int, string&gt; mapping = {
            {0, ""},
            {1, "One"},
            {2, "Two"},
            {3, "Three"},
            {4, "Four"},
            {5, "Five"},
            {6, "Six"},
            {7, "Seven"},
            {8, "Eight"},
            {9, "Nine"},
            {10, "Ten"},
            {11, "Eleven"},
            {12, "Twelve"},
            {13, "Thirteen"},
            {14, "Fourteen"},
            {15, "Fifteen"},
            {16, "Sixteen"},
            {17, "Seventeen"},
            {18, "Eighteen"},
            {19, "Nineteen"},
            {20, "Twenty"},
            {30, "Thirty"},
            {40, "Forty"},
            {50, "Fifty"},
            {60, "Sixty"},
            {70, "Seventy"},
            {80, "Eighty"},
            {90, "Ninety"}
        };
        return mapping.at(num);
    }

    string BelowHundred(int num) {
        // num &lt; 100.
        if (num &lt; 20) {
            return TokenTranslate(num);
        }
        int tens = (num / 10) * 10;
        return join({
            TokenTranslate(tens), TokenTranslate(num - tens)
        });
    }

    string BelowThousand(int num) {
        // num &lt; 1000.
        if (num &lt; 100) {
            return BelowHundred(num);
        }
        return join({
            BelowHundred(num / 100), "Hundred", BelowHundred(num - (num / 100) * 100)
        });
    }
};

</code></pre>

<!--
<h2>273. Integer to English Words  </h2>
-->


<h2>410. Split Array Largest Sum BAIDU</h2>

<div class="question-content">
<p>Given an array which consists of non-negative integers and an integer <i>m</i>, you can split the array into <i>m</i> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <i>m</i> subarrays.
</p>

<p><b>Note:</b><br>
Given <i>m</i> satisfies the following constraint: 1 ≤ m ≤  length(nums) ≤ 14,000.
</p>

<p><b>Examples: </b>
</p><pre>Input:
<b>nums</b> = [7,2,5,10,8]
<b>m</b> = 2

Output:
18

Explanation:
There are four ways to split <b>nums</b> into two subarrays.
The best way is to split it into <b>[7,2,5]</b> and <b>[10,8]</b>,
where the largest sum among the two subarrays is only 18.
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int splitArray(vector&lt;int&gt;&amp; nums, int m) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() < m) {
            return 0;
        }
        long max = sum(nums);
        long min = MaxVal(nums);
        while (min < max) {
            const long mid = (min + max) / 2;
            if (IsValid(nums, m, mid)) {
                // It is valid to find a partition of m sub arrays with the
                // largest sum <= mid.
                // In this case, we should try a smaller mid to see whether
                // there are better solutions.
                max = mid;
            } else {
                // We increase mid to see whether there is valid solution.
                min = mid + 1;
            }
        }
        return min;
    }

    // Returns true if there is one partition of m with the largest sum <= max.
    // This function can be done in O(n).
    bool IsValid(const vector&lt;int&gt; &amp;n, int m, long max) {
        long sum = 0;
        int group = 1;
        for (const int i : n) {
            if (sum + i <= max) {
                // Put as many element as possible into previous partition.
                sum += i;
            } else {
                // The previous partition ends, start a new partition.
                sum = i;
                ++group;
            }
            if (group > m || sum > max) {
                return false;
            }
        }
        return true;
    }

    // Sum of vectors, using long because int will over flow.
    long sum(const vector&lt;int&gt; &amp;n) {
        long ret = 0;
        for (const int i : n) {
            ret += i;
        }
        return ret;
    }

    // The max value in the vector.
    int MaxVal(const vector&lt;int&gt; &amp;n) {
        int ret = 0;
        for (const int i : n) {
            ret = std::max(ret, i);
        }
        return ret;
    }
};
</code></pre>

<!--
<h2>410. Split Array Largest Sum BAIDU</h2>
-->

<h2>161. One Edit Distance SNAPCHAT</h2>
<p>Given two strings S and T, determine if they are both one edit distance apart.
</p>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        if (s.empty() || t.empty()) {
            return s.size() + t.size() == 1;
        }
        if (s.size() == t.size()) {
            // When the two has the same size, check whether only one char differs.
            int diff = 0;
            for (int i = 0; i < s.size() &amp;&amp; diff <= 1; ++i) {
                // Put diff <= 1 here to early terminate the loop.
                if (s.at(i) != t.at(i)) {
                    ++diff;
                }
            }
            return diff == 1;
        }
        // Find the shorter string.
        const string &amp;small = s.size() < t.size() ? s : t;
        const string &amp;large = s.size() < t.size() ? t : s;
        if (small.size() + 1 != large.size()) {
            // If the two has distance not equal to one, false.
            return false;
        }
        for (int i = 0; i < small.size(); i++) {
            if (small.at(i) != large.at(i)) {
                // Find the first character mismatch, than compare the following characters.
                return small.substr(i) == large.substr(i + 1);
            }
        }
        return true;
    }
};
</code></pre>
<!--
<h2>161. One Edit Distance</h2>
-->

<h2>36. Valid Sudoku </h2>

<div class="question-content">
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A partially filled sudoku which is valid.</p>
<p></p>

<p><b>Note:</b><br>
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using BOA = vector&lt;vector&lt;char&gt;&gt;;

    bool ValidOrAdd(bitset&lt;9&gt; *n, const char val) {
        if (val != '.') {
            const int p = val - '1';
            if (n->test(p)) {
                return false;
            } else {
                n->set(p);
                return true;
            }
        }
        return true;
    }

    bool isValidSudoku(const BOA &amp;b) {
        for (int i = 0; i < 9; i++) {
             bitset&lt;9&gt; n;
             for (int j = 0; j < 9; j++) {
                 if (!ValidOrAdd(&amp;n, b[i][j])) {
                     return false;
                 }
             }
        }
        for (int j = 0; j < 9; j++) {
            bitset&lt;9&gt; n;
            for (int i = 0; i < 9; i++) {
                if (!ValidOrAdd(&amp;n, b[i][j])) {
                    return false;
                }
            }
        }
        for (int i = 0; i < 9; i+=3) {
            for (int j = 0; j < 9; j+=3) {
                bitset&lt;9&gt; n;
                for (int k = i; k < i + 3; k++) {
                    for (int f = j; f < j + 3; f++) {
                        if (!ValidOrAdd(&amp;n, b[k][f])) {
                            return false;
                        }
                    }
                }
            }
        }

        return true;
    }
};
</code></pre>

<!--
<h2>36. Valid Sudoku </h2>
-->

<h2>37. Sudoku Solver SNAPCHAT</h2>

<div class="question-content">
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character <code>'.'</code>.</p>

<p>You may assume that there will be only one unique solution.

</p><p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>
</p><p style="font-size: 11px">A sudoku puzzle...</p>
<p></p>

<p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"><br>
</p><p style="font-size: 11px">...and its solution numbers marked in red.
</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        solve(board);
    }
private:

    using BOA = vector&lt;vector&lt;char&gt;&gt;;
    using BIT = bitset&lt;9&gt;;
    struct POS {
        int r;
        int c;
        int cell() const {
            return (r/3) * 3 + (c/3);
        }
    };

    BIT row[10];
    BIT col[10];
    BIT cell[10];

    void change(BIT *val, int num, bool bitval) {
        if (bitval) {
            val->set(num);
        } else {
            val->reset(num);
        }
    }

    bool valid(const BOA &amp;b, const POS &amp;p, char val) {
        // Returns true if it is OK to put val in (r, c).
        const int test = val - '1';
        return !(row[p.r].test(test)) &amp;&amp; !(col[p.c].test(test)) &amp;&amp; !(cell[p.cell()].test(test));
    }

    void set(BOA &amp;b, const POS &amp;p, char val) {
        const int test = val - '1';
        b[p.r][p.c] = val;
        change(&amp;row[p.r], test, true);
        change(&amp;col[p.c], test, true);
        change(&amp;cell[p.cell()], test, true);
    }

    void clear(BOA &amp;b, const POS &amp;p) {
        const int test = b[p.r][p.c] - '1';
        b[p.r][p.c] = '.';
        change(&amp;row[p.r], test, false);
        change(&amp;col[p.c], test, false);
        change(&amp;cell[p.cell()], test, false);
    }

    bool helper(BOA &amp;b, vector&lt;POS&gt; &amp;candi) {
        if (candi.empty()) {
            return true;
        }
        const POS p = *candi.rbegin();
        candi.pop_back();
        for (char d = '1'; d <= '9'; d++) {
            if (valid(b, p, d)) {
                set(b, p, d);
                if (helper(b, candi)) return true;
                clear(b, p);
            }
        }
        candi.push_back(p);
        return false;
    }

    void sort(vector&lt;POS&gt; &amp;candi) {
        std::sort(candi.begin(), candi.end(), [this](const POS &amp;a, const POS &amp;b) {
            int c_a = row[a.r].count() + col[a.c].count() + cell[a.cell()].count();
            int c_b = row[b.r].count() + col[b.c].count() + cell[b.cell()].count();
            return c_a < c_b;
        });
    }

    bool solve(BOA &amp;board) {
        vector&lt;POS&gt; candi;
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                const POS p {r, c};
                if (board[p.r][p.c] != '.') {
                    set(board, p, board[p.r][p.c]);
                } else {
                    candi.push_back(p);
                }
            }
        }
        sort(candi);
        return helper(board, candi);
    }
};
</code></pre>

<!--
<h2>37. Sudoku Solver </h2>
-->

<h2>127. Word Ladder </h2>
<div class="question-content">
<p>
Given two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find the length of shortest transformation sequence from <i>beginWord</i> to <i>endWord</i>, such that:
</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the word list</li>
</ol>

<p>
For example,
</p>
<p>
Given:<br>
<i>beginWord</i> = <code>"hit"</code><br>
<i>endWord</i> = <code>"cog"</code><br>
<i>wordList</i> = <code>["hot","dot","dog","lot","log"]</code><br>
</p>
<p>
As one shortest transformation is <code>"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"</code>,<br>
return its length <code>5</code>.
</p>

<p>
<b>Note:</b><br>
</p><ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using SET = unordered_set&lt;string&gt;;
    int ladderLength(string beg, string end, unordered_set&lt;string&gt;&amp; w) {
        if (beg == end) {
            return 1;
        }
        SET left, right, *pleft, *pright;
        int dist = 2;
        left.insert(beg);
        right.insert(end);
        w.erase(beg);
        w.erase(end);

        while (!left.empty() &amp;&amp; !right.empty()) {
            if (left.size() <= right.size()) {
                // We plan to process the one with smaller size first.
                // As it can be more balanced in that way.
                pleft = &amp;left;
                pright = &amp;right;
            } else {
                pleft = &amp;right;
                pright = &amp;left;
            }
            SET temp; // Store all neighbors of elements in pleft.
            for (string v : *pleft) {
                for (int i = 0; i < v.size(); ++i) {
                const char ori = v[i];
                for (char d = 'a'; d <= 'z'; ++d) {
                    v[i] = d;
                    if (pright->find(v) != pright->end()) {
                        return dist;
                    }
                    if (w.find(v) != w.end()) {
                        temp.insert(v);
                        w.erase(v);
                    }
                }
                v[i] = ori;
            }
            }
            swap(*pleft, temp);
            ++dist;
        }
        return 0;
    }
};
</code></pre>

<h2>253. Meeting Rooms II</h2>

<div class="question-content">
 <p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (s<sub>i</sub> &lt; e<sub>i</sub>), find the minimum number of conference rooms required.</p>

<p>
For example,<br>
Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>
return <code>2</code>.
</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) {
        if(intervals.size() == 0) {
            return 0;
        }
        map&lt;int, int&gt; map;
        // We have to use map here as the keys need to be sorted.
        // Thus the time complexity is O(nlogn).
        for(auto interval : intervals) {
            map[interval.start]++;
            map[interval.end]--;
        }
        int count = 0;
        int result = 0;
        for(auto it = map.begin() ; it != map.end() ; ++it) {
            count = count + it -> second;
            result = max(result, count);
        }
        return result;
    }
};
</code></pre>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
# Definition for an interval.
# class Interval(object):
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution(object):
    def minMeetingRooms(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """
        if not intervals:
            return 0
        intervals.sort(key=lambda x: x.start)
        rooms = []
        end_time_of_first_room = intervals[0].end
        heapq.heappush(rooms, end_time_of_first_room)
        for i in xrange(1, len(intervals), 1):
            start, end = intervals[i].start, intervals[i].end
            earliest_room_end_time = rooms[0]
            if start < earliest_room_end_time:
                heapq.heappush(rooms, end)
            else:
                heapq.heappushpop(rooms, end)
        return len(rooms)
</code></pre>


<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) {
        if (intervals.empty()) {
            return 0;
        }
        // Sort according to start time.
        sort(intervals.begin(), intervals.end(), [](const Interval &amp;a, Interval &amp;b) {
            return a.start < b.start;
        });
        // Top is min value, heap for the end times.
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; end_times;
        end_times.push(intervals[0].end);
        for (int i = 1; i < intervals.size(); ++i) {
            const int end_t = intervals[i].end;
            const int start_t = intervals[i].start;
            if (start_t < end_times.top()) {
                // Need a new room, as the next start time is earlier than the earliest end time.
                end_times.push(end_t);
            } else {
                // One room is available for the next start meeting, use that room instead.
                end_times.pop();
                end_times.push(end_t);
            }
        }
        // The size of the queue is the largest room used.
        return end_times.size();
    }
};
</code></pre>

<h2>206. Reverse Linked List   </h2>

<p>Reverse a singly linked list.</p>


<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode *next = head->next;
        ListNode *new_head = reverseList(next);
        next->next = head;
        head->next = nullptr;
        return new_head;

    }
};
</code></pre>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode *p = head;
        ListNode *q = head->next;
        ListNode *temp = nullptr;

        while (q) {
            temp = q->next;
            q->next = p;
            p = q;
            q = temp;
        }
        head->next = nullptr;
        return p;
    }
};
</code></pre>

<h2>96. Unique Binary Search Trees   </h2>

<div class="question-content">
<p>Given <i>n</i>, how many structurally unique <b>BST's</b> (binary search trees) that store values 1...<i>n</i>?</p>

<p>
For example,<br>
Given <i>n</i> = 3, there are a total of 5 unique BST's.

</p><pre>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
</div>
<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    int numTrees(int n) {
        vector&lt;int&gt; dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; j++) {
                // put j as the root.
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
</code></pre>

<h2>151. Reverse Words in a String</h2>

<div class="question-content">
<p>
Given an input string, reverse the string word by word.
</p>

<p>
For example,<br>
Given s = "<code>the sky is blue</code>",<br>
return "<code>blue is sky the</code>".
</p>

<p>
<b><font color="red">Update (2015-02-12):</font></b><br>
For C programmers: Try to solve it <i>in-place</i> in <i>O</i>(1) space.
</p>

<div><b>Clarification:</b>

<p>
</p><ul>
<li>What constitutes a word?<br>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>
Reduce them to a single space in the reversed string.</li>
</ul>
<p></p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    void reverseWords(string &amp;s) {
      stripSpace(s);
      reverse(s.begin(), s.end());
      int begin = 0, end = 0;
      while (begin < s.size()) {
        end = begin;
        while (end < s.size() &amp;&amp; s[end] != ' ') {
          ++end;
        }
        reverse(s.begin() + begin, s.begin() + end);
        begin = end + 1;
      }
    }

    void stripSpace(string &amp;s) {
      if (s.empty()) {
        return;
      }
      int p = 0;
      int w = 0;
      while (w < s.size() &amp;&amp; s[w] == ' ') {
        ++w;
      }
      while (w < s.size()) {
        if (s[w] == ' ') {
          if (w + 1 < s.size() &amp;&amp; s[w + 1] != ' ') {
            s[p++] = s[w++];
            continue;
          }
        } else {
          s[p++] = s[w++];
          continue;
        }
        ++w;
      }
      s.resize(p);
    }
};
</code></pre>

<h2>403. Frog Jump   </h2>

<div class="question-content">
<p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>

<p>Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.
</p>

<p>If the frog's last jump was <i>k</i> units, then its next jump must be either <i>k</i> - 1, <i>k</i>, or <i>k</i> + 1 units. Note that the frog can only jump in the forward direction.</p>

<p><b>Note:</b>
</p><ul>
<li>The number of stones is ≥ 2 and is &lt; 1,100.</li>
<li>Each stone's position will be a non-negative integer &lt; 2<sup>31</sup>.</li>
<li>The first stone's position is always 0.</li>
</ul>

<p><b>Example 1:</b>
</p><pre><b>[0,1,3,5,6,8,12,17]</b>

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

<b>Return true</b>. The frog can jump to the last stone by jumping
1 unit to the 2nd stone, then 2 units to the 3rd stone, then
2 units to the 4th stone, then 3 units to the 6th stone,
4 units to the 7th stone, and 5 units to the 8th stone.
</pre>

<p><b>Example 2:</b>
</p><pre><b>[0,1,2,3,4,8,9,11]</b>

<b>Return false</b>. There is no way to jump to the last stone as
the gap between the 5th and 6th stone is too large.
</pre>
</div>



<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using SET = unordered_set&lt;int&gt;;

    void updateJump(unordered_map&lt;int, SET&gt; &amp;s, int unit, int k) {
        if (k > 0) {
            const int next_unit = unit + k;
            auto it = s.find(next_unit);
            if (it != s.end()) {
                it->second.insert(k);
            }
        }
    }

    bool canCross(vector&lt;int&gt;&amp; stones) {
        if (stones.empty()) {
            return true;
        }
        // Stores all possible last-jumps for stone unit at a specific position.
        unordered_map&lt;int, SET&gt; stones_to_jump = {{0, {0}}};
        for (const int unit : stones) {
            if (unit > 0) {
                // Pre insert all stone unit into the map, this can
                // facilitate a little.
                stones_to_jump[unit] = {};
            }
        }
        // This points to all possible last-jumps for the last stone unit.
        auto final_iter = stones_to_jump.find(stones.back());
        for (const int unit : stones) {
            auto it = stones_to_jump.find(unit);
            if (it->second.empty()) {
                // If empty, then means no possible jumps to stone at &lt;unit&gt;
                continue;
            }
            for (const int jump : it->second) {
                // Update all other jumps starting from &lt;unit&gt;.
                updateJump(stones_to_jump, unit, jump - 1);
                updateJump(stones_to_jump, unit, jump);
                updateJump(stones_to_jump, unit, jump + 1);
            }
            if (!final_iter->second.empty()) {
                // This means we already find one solution, directly return.
                return true;
            }
        }
        return !final_iter->second.empty();
    }
};
</code></pre>


<h2>270. Closest Binary Search Tree Value </h2>

<div class="question-content">
<p>
Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.
</p>
<p><b>Note:</b><br>
</p><ul>
<li>Given target value is a floating point.</li>
<li>You are guaranteed to have only one unique value in the BST that is closest to the target.</li>
</ul>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ret_;
    int closestValue(TreeNode* root, double target) {
        if (root == nullptr) {
            return 0;
        }
        ret_ = root->val;
        return helper(root, target, abs(target - root->val));
    }

    int helper(TreeNode *root, double target, double dis) {
        if (root == nullptr) {
            return ret_;
        }
        const double new_dis = abs(target - root->val);
        if (new_dis < dis) {
            ret_ = root->val;
        }
        dis = min(new_dis, dis);
        if (target < root->val) {
            return helper(root->left, target, dis);
        } else {
            return helper(root->right, target, dis);
        }
    }
};
</code></pre>

<h2>402. Remove K Digits </h2>

<div class="question-content">
<p>Given a non-negative integer <i>num</i> represented as a string, remove <i>k</i> digits from the number so that the new number is the smallest possible.
</p>

<p><b>Note:</b><br>
</p><ul>
<li>The length of <i>num</i> is less than 10002 and will be ≥ <i>k</i>.</li>
<li>The given <i>num</i> does not contain any leading zero.</li>
</ul>

<p><b>Example 1:</b>
</p><pre>Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>

<p><b>Example 2:</b>
</p><pre>Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>

<p><b>Example 3:</b>
</p><pre>Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    string removeKdigits(string num, const int k) {
        if (num.size() <= k) {
            return "0";
        }
        if (num == "0") {
            return num;
        }
        string res;
        // We always choose to pop out the largest value in the stack.
        int deleted = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (res.empty() &amp;&amp; num[i] == '0') {
                // Lead value cannot be 0. So skip to the next value.
                continue;
            }
            if (deleted == k || res.empty() || num[i] >= res.back()) {
                // 3 conditions:
                //   1, We have deleted enough value, so simply insert all remains.
                //   2, No available value right now, in this case num[i] != '0'
                //      by default so insert it.
                //   3, The next value is larger, so insert it as it should
                //      have a higher priority to delete the the current
                //       top one in stack.
                res.push_back(num[i]);
                continue;
            }
            // Pop all previous string out.
            // We meet a value smaller than the current stack top,
            // so delete the current stack top.
            res.pop_back();
            --i;
            ++deleted;
        }
        // res: first element is not 0, but its length maybe longer or shorter
        //      as deleted may not equal to k.
        res = res.substr(0, num.size() - k);
        return res.empty() ? "0" : res;
    }
};
</code></pre>


<h2>289. Game of Life </h2>

<div class="question-content">
<p>
According to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank">Wikipedia's article</a>: "The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."
</p>

<p>
Given a <i>board</i> with <i>m</i> by <i>n</i> cells, each cell has an initial state <i>live</i> (1) or <i>dead</i> (0). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
</p>

<p>
</p><ol>
<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>

<p>
Write a function to compute the next state (after one update) of the board given its current state.</p>

<p>
<b>Follow up</b>: <br>
</p><ol>
<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>
<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>
</ol>

<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    using BOA = vector&lt;vector&lt;int&gt;&gt;;
    int numlive(const BOA &amp;b, const int i, const int j) {
        int res;
        for (int k = max(0, i - 1); k <= i + 1 &amp;&amp; k < b.size(); ++k) {
            for (int f = max(0, j - 1); f <= j + 1 &amp;&amp; f < b[0].size(); ++f) {
                if (k != i || f != j) {
                    res += (b[k][f] &amp; 1);
                }
            }
        }
        return res;
    }

    void gameOfLife(BOA&amp; b) {
        if (b.empty() || b[0].empty()) {
            return;
        }
        const int m = b.size();
        const int n = b[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                const int num_live = numlive(b, i, j);
                const bool is_live = (b[i][j] &amp; 1);
                // cout &lt;&lt; is_live &lt;&lt; " " &lt;&lt; num_live &lt;&lt; " " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;
                if (is_live) {
                    if (num_live < 2 || num_live > 3) {
                        // Die
                    } else {
                        // Live
                        b[i][j] |= 2;
                    }
                } else {
                    if (num_live == 3) {
                        b[i][j] |= 2;
                    }
                }
            }
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                b[i][j] = (b[i][j] &gt;&gt; 1) &amp; 1;
            }
        }
    }
};
</code></pre>

<h2>439. Ternary Expression Parser</h2>
<div class="question-content">
<p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits <code>0-9</code>, <code>?</code>, <code>:</code>, <code>T</code> and <code>F</code> (<code>T</code> and <code>F</code> represent True and False respectively).

</p><p><b>Note:</b>
</p><ol>
<li>The length of the given string is ≤ 10000.</li>
<li>Each number will contain only one digit.</li>
<li>The conditional expressions group right-to-left (as usual in most languages).</li>
<li>The condition will always be either <code>T</code> or <code>F</code>. That is, the condition will never be a digit.</li>
<li>The result of the expression will always evaluate to either a digit <code>0-9</code>, <code>T</code> or <code>F</code>.</li>
</ol>
<p></p>

<p>
<b>Example 1:</b>
</p><pre><b>Input:</b> "T?2:3"

<b>Output:</b> "2"

<b>Explanation:</b> If true, then result is 2; otherwise result is 3.
</pre>
<p></p>

<p>
<b>Example 2:</b>
</p><pre><b>Input:</b> "F?1:T?4:5"

<b>Output:</b> "4"

<b>Explanation:</b> The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"
          -&gt; "(F ? 1 : 4)"                 or       -&gt; "(T ? 4 : 5)"
          -&gt; "4"                                    -&gt; "4"
</pre>
<p></p>

<p>
<b>Example 3:</b>
</p><pre><b>Input:</b> "T?T?F:5:3"

<b>Output:</b> "F"

<b>Explanation:</b> The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"
          -&gt; "(T ? F : 3)"                 or       -&gt; "(T ? F : 5)"
          -&gt; "F"                                    -&gt; "F"
</pre>
</div>

<pre class="prettyprint">
<code class="lang-cc" id="mycode">
class Solution {
public:
    string parseTernary(string e) {
        if (e.empty()) {
            return "";
        }
        if (e.size() == 1) {
            return e;
        }
        if (e[1] == ':') {
            return e.substr(0, 1);
        }
        if (e[0] == 'T') {
            return parseTernary(e.substr(2));
        } else if (e[0] == 'F') {
            int mat = 1;
            int i = 2;
            for (; i < e.size(); ++i) {
                if (e[i] == '?') {
                    ++mat;
                } else if (e[i] == ':') {
                    --mat;
                }
                if (mat == 0) break;
            }
            return parseTernary(e.substr(i + 1));
        } else {
            return e.substr(0, 1);
        }
    }
};
</code></pre>


<script src="http://code.jquery.com/jquery-2.2.2.min.js"></script>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</body>

